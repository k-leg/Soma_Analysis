---
title: "Somascan_Analysis"
format: html
editor: visual
---

# Read in the adat file and manipulate the dataframe

```{r}
library("SomaDataIO")

master <- read_adat("~/Documents/R scripts/Soma_project/L0125004423_v5.0_EDTAPlasma.hybNorm.medNormInt.plateScale.calibrate.anmlQC.qcCheck.anmlSMP.20251008.adat")

head(master)

```

```{r}
library(dplyr)

#remove calibrators and flagged samples
df <- master %>%
  filter(
    !SampleType %in% c("Calibrator", "Buffer", "QC"),
    RowCheck != "FLAG"
  ) %>% as_tibble()

#remove unwanted columns

df <- df %>% dplyr::select(-PlateId,-PlateRunDate, -ScannerID, -PlatePosition, -SlideId, -Subarray,-PercentDilution,-SampleMatrix,-Barcode,-Barcode2d,-SampleNotes,-AliquotingNotes, -SampleDescription, -AssayNotes, -ExtIdentifier, -SsfExtId,-SampleGroup,-SubjectID, -CLI, -RMA, -HybControlNormScale,-NormScale_20, -NormScale_0_005, -NormScale_0_5, -ANMLFractionUsed_20, -ANMLFractionUsed_0_005, -ANMLFractionUsed_0_5,-SiteId,-TimePoint, -SampleName, -SampleType, -RowCheck)

rownames(df) = NULL

```

## convert seq IDs to Uniprot

```{r}
library(stringr)
library(readr)
library(dplyr)

#load in the conversion key csv
map <- read.csv("seqid_to_uniprot.csv")

#reformatting (eg. 10023-32 to seq.10023.32)
map <- map %>% mutate(
  seqid_formatted = paste0("seq.", gsub("-",".",SeqId))
)

# make the vector from the map df
id_map <- setNames(map$UniProtID, map$seqid_formatted)

# don't rename the seqID column
old_names <- colnames(df)
new_names <- old_names
new_names[-1] <- ifelse(
  old_names[-1] %in% names(id_map),
  id_map[old_names[-1]],
  old_names[-1]
)

colnames(df) <- new_names

#remove any columns that still start with "seq" because these are controls

names(df) <- make.unique(names(df)) # some somamer sequences map to the same uniprotID but different regimes of the protein(cytoplasmic vs extracellular, etc. this makes the column names unique to avoid errors on dplyr.)

df <- df %>% dplyr::select(-starts_with("seq"))

```

# Add a Timepoint and Subject ID column

```{r}
df <- df %>%
  mutate(
    Timepoint = str_extract(SampleId, "D[1-5]$"),       # extract D1–D5 at the end
    SubjectID = str_remove(SampleId, "D[1-5]$")         # remove D1–D5 to get the subject ID
  ) %>%
  relocate(SubjectID, .before = SampleId) %>%            # move SubjectID before SampleId
  relocate(Timepoint, .after = SampleId)

df$Timepoint <- factor(df$Timepoint)

df <- as_tibble(df)
```

# log2 transformation of the proteomics data

```{r}

df_log2 <- df %>% mutate(across(where(is.numeric), ~ log2(.x)))

```

# Plot analytes of interest

```{r}
library(tidyverse)

# Vector of target proteins
target_proteins <- c("P05231","P0DJI8","Q14116")

# Convert to long format for ggplot
df_long <- df %>%
  pivot_longer(cols = all_of(target_proteins),
               names_to = "Protein",
               values_to = "Expression")

# Summary stats: mean and SE per group
summary_df <- df_long %>%
  group_by(Protein, Timepoint) %>%
  summarise(
    mean_expr = mean(Expression, na.rm = TRUE),
    sd_expr = sd(Expression, na.rm = TRUE),
    .groups = "drop"
  )

# Plot
plot1 <- ggplot(summary_df, aes(x = Timepoint, y = mean_expr, fill = Timepoint)) +
  geom_col(position = "dodge", color = "black", width = 0.8) +
  geom_errorbar(aes(ymin = mean_expr - sd_expr, ymax = mean_expr + sd_expr),
                width = 0.2, position = position_dodge(0.7)) +
  facet_wrap(~ Protein, scales = "free_y", ncol = 4) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 13, margin = margin(b=20)),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  ) +
  labs(
    title = "",
    x = "Draw",
    y = "Mean Expression"
  )
```

# Start with a basic heatmap visualization appraoch

```{r}
library(pheatmap)
library(dplyr)

dir.create("heatmap_clusters", showWarnings = FALSE)
# loop over each timepoint
for(tp in levels(df_log2$Timepoint)) {
  
  # subset that timepoint
  df_tp <- df_log2 %>%
    filter(Timepoint == tp) %>%
    dplyr::select(-SubjectID, -SampleId, -Timepoint)
  
  # convert to matrix
  mat <- as.matrix(df_tp)

  rownames(mat) <- df_log2 %>%
    filter(Timepoint == tp) %>%
    pull(SubjectID)
  
  #This part is defining the proteins that are above or below a threshold z scored expression value so i can label them
  
  mat_scaled <- t(scale(t(mat)))


  # heatmap
  ph <- pheatmap(mat_scaled,
           clustering_method = "ward.D2",
           scale = "none", # change this to column if you are looking to find differences between samples instead of global trends.
           main = paste("Protein Expression —", tp),
           show_rownames = TRUE,
           show_colnames = FALSE,
           cutree_cols = 8)


col_hclust <- ph$tree_col
col_clusters <- cutree(ph$tree_col, k=8)
annotation_col <- data.frame(Cluster = factor(col_clusters))
rownames(annotation_col) <- names(col_clusters)

  # Choose colors for clusters
  ann_colors <- list(
    Cluster = setNames(
      RColorBrewer::brewer.pal(8, "Paired"),
      levels(annotation_col$Cluster)
    )
  )

  # Re-plot heatmap with cluster annotation bar
  pheatmap(mat_scaled,
           clustering_method = "ward.D2",
           scale = "none",
           main = paste("Protein Expression —", tp),
           show_rownames = FALSE,
           show_colnames = FALSE,
           annotation_col = annotation_col,   # ✅ adds color bar
           annotation_colors = ann_colors,
           cutree_cols = 9,
           border_color = NA)

cluster_df <- tibble(
  Protein = names(col_clusters),
  Cluster = col_clusters
)

cluster_file <- paste0("heatmap_clusters/Protein_clusters_", tp, ".csv")
write_csv(cluster_df, cluster_file)

  }

```

# Linear mixed effects model to find proteins differentially expressed over time

```{r}
library(lme4)
library(lmerTest)
library(emmeans)
library(purrr)


# Restructure the dataframe from wide to long

df_long <- df_log2 %>% pivot_longer(
  cols = where(is.numeric),
  names_to = "Protein",
  values_to = "Expression",
)

# Fit the LMEM by protein
results <- df_long %>%
  group_by(Protein) %>%
  nest() %>%
  mutate(
    model = purrr::map(data, ~ lmer(Expression ~ Timepoint + (1 | SubjectID), data = .x)),
    anova_res = map(model, ~ anova(.x)),
    F_value = map_dbl(anova_res, ~ .x$`F value`[1]),
    p_value = map_dbl(anova_res, ~ .x$`Pr(>F)`[1])
  ) %>%
  ungroup() %>%
  dplyr::mutate(FDR = p.adjust(p_value, method = "fdr")) %>%
  arrange(FDR)

# Extract significant proteins
sig_proteins <- results %>% filter(FDR < 0.05)

```

# Post-hoc testing and ranking

```{r}
library(broom)

# Post-hoc test. I am using Tukey, but I'm not sure what the best post-hoc test is. need to read. Tukey is more conservative than FDR on this dataset.
posthoc <- sig_proteins %>%
  mutate(
    emmeans_res = map(model, ~ emmeans(.x, pairwise ~ Timepoint, adjust = "tukey"))
  )

# Extract pairwise contrasts
pairwise_tukey <- posthoc %>%
  mutate(
    contrasts = map(emmeans_res, ~ as_tibble(summary(.x$contrasts)))  # <-- convert to tibble
  ) %>%
  dplyr::select(Protein, contrasts) %>%
  unnest(contrasts) %>%
  filter(p.value < 0.05)

# Also get modeled means, to label “overexpressed at”
emm_means <- posthoc %>%
  mutate(emmeans_tbl = map(emmeans_res, ~ as_tibble(summary(.x$emmeans)))) %>%
  dplyr::select(Protein, emmeans_tbl) %>%
  unnest(emmeans_tbl)

# A simple label: timepoint with highest modeled mean per protein
overexpressed <- emm_means %>%
  group_by(Protein) %>%
  filter(emmean == max(emmean)) %>%
  dplyr::rename(OverexpressedAt = Timepoint)

# Final per-protein summary (omnibus FDR + peak timepoint)
final_summary <- sig_proteins %>%
  left_join(overexpressed, by = "Protein") %>%
  dplyr::select(Protein, p_value, FDR, OverexpressedAt, emmean) %>%
  arrange(FDR)
```

# Limma method of differentially expressed proteins

```{r}
library(limma)

dir.create("limma_results", showWarnings = FALSE)
# Create design matrix for timepoint comparison
design <- model.matrix(~ 0 + Timepoint, data = df_log2)
# ~0 sets y intercept to zero
colnames(design) <- levels(df_log2$Timepoint)

expr_matrix <- df_log2 %>% dplyr::select((where(is.numeric))) %>% as.matrix()
# Fit the model
expr_matrix_transpose <- expr_matrix %>% t() # transpose the matrix. I found I had to do this.

# # Make contrasts to find the proteins that are highly expressed per timepoint


contrast_matrix <- makeContrasts(
  D1_v_D2 = D1 - D2,
  D2_v_D3 = D2 - D3,
  D3_v_D4 = D3 - D4,
  D3_v_D5 = D3 - D5,
  D4_v_D5 = D4 - D5,
  D1_v_D5 = D1 - D5,
  D2_v_D5 = D5 - D2,
  levels = design
)

#Estimate Sample Correlation
SubjectID <- df_log2$SubjectID
corfit <- duplicateCorrelation(expr_matrix_transpose, design, block = SubjectID)

#Fit the model
fit <- lmFit(expr_matrix_transpose, design, block = SubjectID, correlation=corfit$consensus)
fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2) #Bayesian noise correction



D1_v_D2 <- topTable(fit2, coef = "D1_v_D2", number = 100)
D2_v_D3 <- topTable(fit2, coef = "D2_v_D3", number = 100)
D3_v_D4 <- topTable(fit2, coef = "D3_v_D4", number = 100)
D3_v_D5 <- topTable(fit2, coef = "D3_v_D5", number = 100)
D4_v_D5 <- topTable(fit2, coef = "D4_v_D5", number = 100)
D1_v_D5 <- topTable(fit2, coef = "D1_v_D5", number = 100)
D2_v_D5 <- topTable(fit2, coef = "D2_v_D5", number = 100)



D1_D2_sig <- D1_v_D2 %>% filter(adj.P.Val < 0.05, logFC > 0)
D2_D3_sig <- D2_v_D3 %>% filter(adj.P.Val < 0.05, logFC > 0)
D3_D4_sig <- D3_v_D4 %>% filter(adj.P.Val < 0.05, logFC > 0)
D3_D5_sig <- D3_v_D5 %>% filter(adj.P.Val < 0.05, logFC > 0)
D4_D5_sig <- D4_v_D5 %>% filter(adj.P.Val < 0.05, logFC > 0)
D2_D5_sig <- D2_v_D5 %>% filter(adj.P.Val < 0.05, logFC > 0)
D1_D5_sig <- D1_v_D5 %>% filter(adj.P.Val < 0.05, logFC > 0)
#late_timepoint_sig <- late_timepoint %>% filter(adj.P.Val < 0.05, logFC > 0)
```

# Pathway, GO and GSEA

-   starting with GSEA: get a list of log2 fold changes between groups of interest, as defined by the groups that clustered separately in PLSDA

-   use the log2fold change to perform GSEA

## GSEA

### Get the log2fold changes
```{r}
library(tidyverse)
library(clusterProfiler)
library(enrichplot)

# compute log2foldchange of D1 vs D2 and D2 vs D3

library(tidyverse)

# D1 vs D2
fc_df <- df_log2 %>%
  filter(Timepoint %in% c("D1", "D2")) %>%
  pivot_longer(
    cols = -c(SubjectID, SampleId, Timepoint),
    names_to = "Protein",
    values_to = "log2_expr"
  ) %>%
  pivot_wider(
    id_cols    = c(SubjectID, Protein),
    names_from = Timepoint,
    values_from = log2_expr
  ) %>%
  filter(!is.na(D1) & !is.na(D2)) %>%
  mutate(log2_FC_D2_vs_D1 = D2 - D1)


ranks_df <- fc_df %>%
  group_by(Protein) %>%
  summarize(meanlog2fc = mean(log2_FC_D2_vs_D1, na.rm = TRUE), .groups = "drop")

# strip probe suffix like ".1" or ".2" from UniProt IDs. This is an artifact of multiple somamer seqIDs mapping to a single protein.
ranks_df <- ranks_df %>%
  mutate(
    UNIPROT_raw = Protein,
    UNIPROT = str_replace(Protein, "\\.\\d+$", ""),   # removes trailing .<digits>
    meanlog2fc = as.numeric(meanlog2fc)
  )

# Collapse duplicates created by stripping suffix. choose the probe with the largest absolute effect size. do not average.

ranks_df <- ranks_df %>%
  group_by(UNIPROT) %>%
  slice_max(order_by = abs(meanlog2fc), n = 1, with_ties = FALSE) %>%
  ungroup()

```

### convert from uniprot to entrez and create ranked vector

```{r}
library(org.Hs.eg.db)
library(AnnotationDbi)

map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys     = unique(ranks_df$UNIPROT),
  keytype  = "UNIPROT",
  columns  = c("ENTREZID")
) %>%
  filter(!is.na(ENTREZID)) %>%
  distinct(UNIPROT, ENTREZID)

#Join mapping; if multiple UniProt map to the same Entrez, collapse to 1 per Entrez
ranks_entrez_df <- ranks_df %>%
  inner_join(map, by = "UNIPROT") %>%
  group_by(ENTREZID) %>%
  slice_max(order_by = abs(meanlog2fc), n = 1, with_ties = FALSE) %>%
  ungroup()

# Create fgsea-ready named vector
ranks_entrez <- ranks_entrez_df$meanlog2fc
names(ranks_entrez) <- ranks_entrez_df$ENTREZID
ranks_entrez <- sort(ranks_entrez, decreasing = TRUE)

```


# Clustering

```{r}
library(tidyverse)
# Define a matrix for prcomp
pca_matrix <- df_log2 %>% dplyr::select((where(is.numeric)))

pca_result <- prcomp(pca_matrix, scale = FALSE)

pca_loadings <- as.data.frame(pca_result$rotation)
pca_loadings <- pca_loadings %>% arrange(PC1, descending = TRUE)

# Get first two principal components
pca_df <- as.data.frame(pca_result$x[, 1:2])
colnames(pca_df) <- c("PC1", "PC2")

pca_df$Timepoint <- df_log2$Timepoint
pca_df$SampleId <- df_log2$SampleId

# Plot
ggplot(pca_df, aes(x = PC1, y = PC2, color = Timepoint)) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "PCA of Samples Colored by Timepoint",
       x = "Principal Component 1", y = "Principal Component 2") +
  theme_minimal(base_size = 16)
```

# PLSDA

```{r}
library(mixOmics)

set.seed(123)
plsda_matrix <- df_log2 %>% dplyr::select((where(is.numeric)))
plsda_response <- df_log2$Timepoint
# run the PLSDA

plsda_result <- splsda(plsda_matrix, plsda_response, ncomp = 3, keepX = c(75,75,75), scale = T) #z scores the data within the plsda
PLS_scores <- as.data.frame(plsda_result$variates$X)
PLS_scores$Response <- df_log2$Timepoint

# plot the result

explained_var <- plsda_result$prop_expl_var$X
x_lab <- paste0("Component 1 (", round(explained_var[1] * 100, 1), "%)")
y_lab <- paste0("Component 2 (", round(explained_var[2] * 100, 1), "%)")


plsda_plot <- ggplot(PLS_scores, aes(x = comp1, y = comp2, color = Response, fill = Response)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(type = "norm", level = 0.85, geom = "polygon", alpha = 0.2, color = NA)+
  scale_fill_discrete(guide = "none") +
  theme_minimal(base_size = 14) +
  labs(
    title = "Proteins over Time",
    x = x_lab,
    y = y_lab,
    color = "Blood Draw Timepoint",
  ) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "right",
    axis.text = element_text(size = 14)
  )

loadings <- as.data.frame(plsda_result$loadings$X) %>%
  rownames_to_column(var="Protein")

top20_loadings <- loadings %>%
  mutate(abs_loading = abs(comp1)) %>%
  arrange(desc(abs_loading)) %>%
  dplyr::slice(1:20)

loadings_plot <- ggplot(top20_loadings, aes(x = reorder(Protein, comp1), y = comp1, fill = comp1 > 0)) +
  geom_col(show.legend = FALSE) +
  scale_fill_manual(values = c("indianred3", "steelblue")) +
  coord_flip() +
  labs(
    title = "Top 20 PLS Loadings (C2)",
    x = "Protein",
    y = "Loading Value"
  ) +
  theme_minimal()
#dir.create("PLSDA_results", showWarnings = FALSE)
write_csv(loadings, "PLSDA_results/PLSDA_loadings.csv")

```

```{r}

#Draw 3 and 2 separate along component 1
loadings_c1 <- plsda_result$loadings$X[,1]
nonzero_c1 <- loadings_c1[loadings_c1!=0]
# Extract D2 and D3 samples for those proteins
proteins <- names(nonzero_c1)

df_sub <- df_log2 %>%
  dplyr::filter(Timepoint %in% c("D2", "D3")) %>%
  dplyr::select(Timepoint, all_of(proteins))

# Compute mean log2 expression per group
mean_expr <- df_sub %>%
  group_by(Timepoint) %>%
  summarise(across(all_of(proteins), mean, na.rm = TRUE)) %>%
  pivot_longer(-Timepoint, names_to = "Protein", values_to = "MeanExpr") %>%
  pivot_wider(names_from = Timepoint, values_from = MeanExpr)

# Calculate log2 fold change (D3 − D2)
mean_expr <- mean_expr %>%
  mutate(log2FC = D3 - D2) %>%
  arrange(desc(abs(log2FC)))

head(mean_expr)
write.csv(mean_expr, "PLSDA_results/nonzeroC1_log2FC_D3vsD2.csv", row.names = FALSE)

```

# Adding in the cell data

## Load the dataset

```{r}
library(dplyr)
cell_df <- read.csv("long_cells.csv", colClasses = c(SubjectID = "character"), header = TRUE)

cell_df$Timepoint <- factor(cell_df$Timepoint)
cell_df$monocytes <- as.numeric(cell_df$monocytes)

cell_df <- cell_df %>% mutate(across(where(is.numeric), 
                                     ~ as.numeric(replace_na(.,mean(.,na.rm=T)))))

cell_df <- cell_df %>% mutate(across(where(is.numeric), ~as.numeric(.x/100)))


# 
# cell_df <- cell_df %>%
#   mutate(across(where(is.numeric),
#                 ~ car::logit((.x ) + 1e-6, adjust = 1e-6)))

head(cell_df)

```

## Integrate with proteomics data

```{r}

integrated_df <- full_join(cell_df,
                           df_log2,
                           by = c("SubjectID","SampleId","Timepoint"))

```

## PLSDA with the integrated data

```{r}
library(mixOmics)

set.seed(123)
plsda_matrix <- integrated_df %>% dplyr::select((where(is.numeric)))
plsda_matrix <- scale(plsda_matrix)
plsda_response <- integrated_df$Timepoint
# run the PLSDA

plsda_integ_result <- splsda(plsda_matrix, plsda_response, ncomp = 2, keepX = c(75,75))
PLS_scores <- as.data.frame(plsda_integ_result$variates$X)
PLS_scores$Response <- integrated_df$Timepoint

# plot the result

explained_var <- plsda_integ_result$prop_expl_var$X
x_lab <- paste0("Component 1 (", round(explained_var[1] * 100, 1), "%)")
y_lab <- paste0("Component 2 (", round(explained_var[2] * 100, 1), "%)")


plsda_plot <- ggplot(PLS_scores, aes(x = comp1, y = comp2, color = Response, fill = Response)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(type = "norm", level = 0.85, geom = "polygon", alpha = 0.2, color = NA)+
  scale_fill_discrete(guide = "none") +
  theme_minimal(base_size = 14) +
  labs(
    title = "PLSDA of cell and protein data",
    x = x_lab,
    y = y_lab,
    color = "Blood Draw Timepoint",
  ) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "right",
    axis.text = element_text(size = 14)
  )

integ_loadings <- as.data.frame(plsda_integ_result$loadings$X) %>%
  rownames_to_column(var="Protein")

top20_loadings <- integ_loadings %>%
  mutate(abs_loading = abs(comp1)) %>%
  arrange(desc(abs_loading)) %>%
  dplyr::slice(1:20)

loadings_plot <- ggplot(top20_loadings, aes(x = reorder(Protein, comp1), y = comp1, fill = comp1 > 0)) +
  geom_col(show.legend = FALSE) +
  scale_fill_manual(values = c("indianred3", "steelblue")) +
  coord_flip() +
  labs(
    title = "Top 20 PLS Loadings (C2)",
    x = "Protein",
    y = "Loading Value"
  ) +
  theme_minimal()

```

### messing around subsetting the data

```{r}
df_subset <- integrated_df %>%
  filter(Timepoint %in% c("D3", "D4", "D5"))

library(mixOmics)

set.seed(123)
plsda_matrix <- df_subset %>% dplyr::select((where(is.numeric)))
plsda_matrix <- scale(plsda_matrix)
plsda_response <- df_subset$Timepoint
# run the PLSDA

plsda_subset_result <- splsda(plsda_matrix, plsda_response, ncomp = 2, keepX = c(75,75))
PLS_scores <- as.data.frame(plsda_subset_result$variates$X)
PLS_scores$Response <- df_subset$Timepoint

# plot the result

explained_var <- plsda_subset_result$prop_expl_var$X
x_lab <- paste0("Component 1 (", round(explained_var[1] * 100, 1), "%)")
y_lab <- paste0("Component 2 (", round(explained_var[2] * 100, 1), "%)")


ggplot(PLS_scores, aes(x = comp1, y = comp2, color = Response, fill = Response)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(type = "norm", level = 0.85, geom = "polygon", alpha = 0.2, color = NA)+
  scale_fill_discrete(guide = "none") +
  theme_minimal(base_size = 14) +
  labs(
    title = "Proteins and Cells over Time",
    x = x_lab,
    y = y_lab,
    color = "Blood Draw Timepoint",
  ) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "right",
    axis.text = element_text(size = 14)
  )

subset_loadings <- as.data.frame(plsda_subset_result$loadings$X) %>%
  rownames_to_column(var="Protein")

top20_loadings <- subset_loadings %>%
  mutate(abs_loading = abs(comp1)) %>%
  arrange(desc(abs_loading)) %>%
  dplyr::slice(1:20)

ggplot(top20_loadings, aes(x = reorder(Protein, comp1), y = comp1, fill = comp1 > 0)) +
  geom_col(show.legend = FALSE) +
  scale_fill_manual(values = c("indianred3", "steelblue")) +
  coord_flip() +
  labs(
    title = "Top 20 PLS Loadings (C2)",
    x = "Protein",
    y = "Loading Value"
  ) +
  theme_minimal()

write_csv(integ_loadings, "PLSDA_results/PLSDA_integ_loadings.csv")
```
